#include <iostream>
#include <opencv2\core\core.hpp>
#include <opencv2\highgui\highgui.hpp>
#include <opencv2\opencv.hpp>
#include <opencv2\imgproc\imgproc.hpp>
#include <vector>
#include <opencv/cvaux.h>
#include <opencv/cv.h>

using namespace cv;
using namespace std;

void connectIpCamera();
int readImage();
void convertGrayscale();
void morphologyOperate1();
void morphologyOperate2();
void dilationImage();
void sobelOperate();
void binaryOtsuImage();
void countRowsCols();
void countBlackPixelsX();
void countBlackPixelsY();
void findingContours();
void countpixelXY();
void blackPixelYCount();
void charBoundRect();
void mergeImage();
void laplacian();
bool verifySizes(RotatedRect mr);


VideoCapture capture;
Mat original_image;
Mat grayscaleimage;
Mat binary1,binary2, equalize;
Mat temp_img, sobelImage;
Mat binaryOtsu,plateCanditate;
Mat morpho,resultMerge,binaryInverted;
Mat firstMerge,binaryMerged;
Mat histogramX, histogramY, binaryHistX, binaryCanditate;
Mat abs_dst;
Mat lapla;
Mat laplacian_image;


int main(int argc, char *argv[]){

	connectIpCamera();

	for (;;){

		readImage();

		convertGrayscale();

//		countRowsCols();

//		morphologyOperate1();

//		morphologyOperate2();

//		dilationImage();

		binaryOtsuImage();

	 	sobelOperate();

//		laplacian();

		mergeImage();

		findingContours();

		if (waitKey(1) >= 0) break;

	}

	waitKey(0);

	destroyAllWindows();

	return 0;
}


void connectIpCamera(){

	string uname = "root";
	string password = "****";
	string ip_address = "http://" + uname + ":" + password + "@169.254.***.1/mjpg/video.mjpg";

	if (capture.open(ip_address) == false) {
		cout << "Cannot connect IP camera! Check Your Camera Connection." << endl;
		waitKey();
	}
}

int readImage(){
	if (capture.read(original_image) == false){
		return -1;
	}
}

void countRowsCols(){
	cout << grayscaleimage.rows << endl;
	cout << grayscaleimage.cols << endl;
}

void morphologyOperate1(){
	Mat morphoImage = imread("morphology_img.jpg");
	threshold(morphoImage, binary1, 170, 255, CV_THRESH_BINARY);
	bitwise_not(binary1,binaryInverted);
	imshow("binaryInverted", binaryInverted);
	imshow("binary1", binary1);
}

void morphologyOperate2(){
	Mat morphoImage = imread("morphology_img.jpg");
	threshold(morphoImage, binary2, 200, 255, CV_THRESH_BINARY);
	bitwise_not(binary2, binaryInverted);
	imshow("binaryInverted", binaryInverted);
	imshow("binary2", binary2);

}
void dilationImage(){
	
	int morph_size = 5;
	Mat element = getStructuringElement(MORPH_RECT, Size(2 * morph_size + 1, 2 * morph_size + 1), Point(morph_size, morph_size));
	morphologyEx(binaryMerged, morpho, MORPH_DILATE, element, Point(-1, -1));
	imshow("morpho", morpho);
//	imwrite("morphology_img.jpg", morpho);
}

void convertGrayscale(){

	cvtColor(original_image, grayscaleimage, CV_BGR2GRAY);
	equalizeHist(grayscaleimage, equalize);
//	imshow("gray image", grayscaleimage);
//	imshow("equalize", equalize);
}

void binaryOtsuImage(){

	threshold(equalize, binaryOtsu, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);
	//	imshow("otsu", binaryOtsu);
}

void sobelOperate(){

	Mat sobelImageX, sobelImageY;

	Sobel(grayscaleimage, temp_img, CV_16S, 1, 0, 1, 3, 5, BORDER_DEFAULT);
	convertScaleAbs(temp_img, sobelImageX, 1, 1);

	Sobel(grayscaleimage, temp_img, CV_16S, 0, 1 ,1, 3, 5, BORDER_DEFAULT);
	convertScaleAbs(temp_img, sobelImageY, 1, 1);

	addWeighted(sobelImageX, 0.4, sobelImageY, 0.4, 0, sobelImage);

	imshow("sobel", sobelImage);
}

void laplacian(){

	Laplacian(sobelImage, lapla, CV_16S ,3,1,0, BORDER_DEFAULT);
	convertScaleAbs(lapla, abs_dst);

//	imshow("laplacian", abs_dst);
}


void mergeImage(){

	Mat firstMerge = binaryOtsu.clone();
	Mat resultMerge = (firstMerge | sobelImage);
	threshold(resultMerge, binaryMerged, 127, 255, CV_THRESH_BINARY);
	imshow("merged_image",  binaryMerged);
}


void findingContours(){

		Mat canny_src = binaryMerged;
		Mat canny_output;

		Canny(canny_src, canny_output, 255, 3, 3);

		Mat minAreaImage = Mat::ones(canny_output.size(), CV_8SC3);
		canny_output.copyTo(minAreaImage);

		imshow("canny_image", minAreaImage);

		vector<vector<Point> > contours;

		// Find contours

		findContours(minAreaImage, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));


		vector<RotatedRect> minRect(contours.size());

		Mat rectanglesImage = original_image.clone();

		const Scalar color = Scalar(255, 255, 0);


		for (size_t i = 0; i < contours.size(); i++){


			minRect[i] = minAreaRect(Mat(contours[i]));

			float rotatedAspectRatio = (float)minRect[i].size.width / (float)minRect[i].size.height;
			float angles = minRect[i].angle;
			float r = (float)minRect[i].size.width / (float)minRect[i].size.height;



			if (minRect[i].size.width > 25 && minRect[i].size.height > 50.0 && rotatedAspectRatio > 0.4  && rotatedAspectRatio < 0.6 && minRect[i].angle < -80.0){

				cout << rotatedAspectRatio << "--" << angles << endl;

				Point2f rect_points[4]; minRect[i].points(rect_points);

				if (angles < 45.0){
					angles += 90.0;
				}
				for (int j = 0; j < 4; j++){

					line(rectanglesImage, rect_points[j], rect_points[(j + 1) % 4], color, 2, 8);
				}

			}


			else if (minRect[i].size.width > 50.0 && minRect[i].size.height > 25.0 && rotatedAspectRatio > 1.85  && rotatedAspectRatio < 2.15 && minRect[i].angle > -10 ){



				Point2f rect_points[4]; minRect[i].points(rect_points);


				for (int j = 0; j < 4; j++){

					line(rectanglesImage, rect_points[j], rect_points[(j + 1) % 4], color, 2, 8);
				}

				//	cout << rotatedAspectRatio << "--" << angles << endl;

					Mat rotmat = getRotationMatrix2D(minRect[i].center, angles, 1);

					//Create and rotate image
					Mat img_rotated;
					warpAffine(grayscaleimage, img_rotated, rotmat, grayscaleimage.size(), CV_INTER_CUBIC);

					//Crop image
					Size rect_size = minRect[i].size;
					if (r < 1)
						swap(rect_size.width, rect_size.height);

					Mat img_crop;
					getRectSubPix(img_rotated, rect_size, minRect[i].center, img_crop);

					Mat resultResized;
					resultResized.create(100, 200, CV_8UC3);
					resize(img_crop, resultResized, resultResized.size(), 0, 0, INTER_CUBIC);
					
					GaussianBlur(resultResized, plateCanditate, Size(1, 1), 0);
					threshold(plateCanditate, binaryCanditate, 0, 255, CV_THRESH_OTSU + CV_THRESH_BINARY);
					
					int xx, xy;

					float averageX, blackPixelRtioX;

					Mat histogramX = Mat(Size(plateCanditate.cols, plateCanditate.rows), CV_8UC3, Scalar(255, 255, 255));

					float sumX = 0;

					for (xx = 0; xx < binaryCanditate.cols; xx++){

						int blackX = 0;

						for (xy = 0; xy < binaryCanditate.rows; xy++){

							int intensity = binaryCanditate.at<uchar>(Point(xx, xy));
							if (intensity == 0){

								blackX += 1;

							}
						}

						line(histogramX, Point(xx, 0), Point(xx, blackX), Scalar(255, 0, 0), 1);
						sumX += blackX;
					}

					averageX = (float)sumX / plateCanditate.cols;
					blackPixelRtioX = (float)(averageX / plateCanditate.cols) * 100;

					//	    cout << averageX << "(" << blackPixelRtioX << " % )" << endl;

					if (blackPixelRtioX > 8.5 && blackPixelRtioX < 13.5){

						int yx, yy;

						float averageY, blackPixelRtioY;
						Mat histogramY = Mat(Size(plateCanditate.cols, plateCanditate.rows), CV_8UC3, Scalar(255, 255, 255));

						float sumY = 0;

						for (yy = 0; yy < binaryCanditate.rows; yy++){

							int blackY = 0;

							for (yx = 0; yx < binaryCanditate.cols; yx++){

								int intensity = binaryCanditate.at<uchar>(Point(yx, yy));
								if (intensity == 0){

									blackY += 1;

								}
							}

							line(histogramY, Point(0, yy), Point(blackY, yy), Scalar(255, 0, 0), 1);
							sumY += blackY;
						}

						 averageY = (float) sumY / plateCanditate.cols;
						 blackPixelRtioY = (float) (averageY / plateCanditate.cols) * 100.0;

						//cout << averageY << "(" << blackPixelRtioY << " % )" << endl;

						if (blackPixelRtioY > 10.0 && blackPixelRtioY < 12.5){

						//	imshow("histogramX.jpg", histogramX);
						//	imshow("histogramY", histogramY);
	
							imshow("plateCanditate", plateCanditate);
							imshow("binaryCanditate", binaryCanditate);
							imwrite("plateCanditate.jpg", plateCanditate);
							imwrite("plateCanditateBinary.jpg", binaryCanditate);

							charBoundRect();

						}
				}

			}
		}

		imshow("plate_detection_result", rectanglesImage);
}


void charBoundRect(){

	vector<vector<Point> > contours;
	vector<Vec4i> hierarchy;
	Mat charImage(binaryCanditate);
	Mat char_output = charImage.clone();
	Mat canyCharImage;

	equalizeHist(charImage, charImage);
	Canny(binaryCanditate, canyCharImage, 255, 3, 3);




	// Find contours
	 
	findContours(canyCharImage, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));

	vector<vector<Point> > contours_poly(contours.size());
	vector<Rect> boundRect(contours.size());
	Scalar color = Scalar(255, 255, 0);

	float fourDigitHeight = (float)canyCharImage.rows * 0.545;
	float fourDigitWidth = (float)char_output.cols * 0.712;
	float katakanaWidth = (float)canyCharImage.cols * 0.181;

	for (size_t i = 0; i < contours.size(); i++){
		approxPolyDP(Mat(contours[i]), contours_poly[i], 3, true);
		boundRect[i] = boundingRect(Mat(contours_poly[i]));
		
		float charXPointRatio =(float) boundRect[i].x / (float)canyCharImage.cols;
		float charAngles = (float) boundRect[i].width / (float)boundRect[i].height;

		float leftSide4Digit = boundRect[i].x - (float)(boundRect[i].x * 0.05) - ((float)(canyCharImage.cols * 0.591));
		float topLine = boundRect[i].y - (float)(boundRect[i].y * 0.05);
		float leftSideKatakana = ( boundRect[i].x - (float)canyCharImage.cols * 0.757) * 0.01;
		float katakanaHeight = (float)(boundRect[i].height/2.0) * 0.10;

		if (charAngles > 0.4 && charAngles < 0.6 && boundRect[i].width > 10.0 && boundRect[i].height > 20.0){

			if (charXPointRatio > 0.718  && charXPointRatio < 0.918){

				Rect Digit(leftSide4Digit, topLine, fourDigitWidth + (fourDigitWidth * 0.10), fourDigitHeight);
				Mat digitRoi = char_output(Digit);
				imwrite("4_digit_number.jpg", digitRoi);

				Rect kana(leftSideKatakana, topLine,katakanaWidth * 1.15, fourDigitHeight);
				Mat katakana = char_output(kana);
				imwrite("katakana.jpg", katakana);


				Rect riku(leftSide4Digit, 0, boundRect[i].x - leftSide4Digit, topLine);
				Mat rikuUnNum = char_output(riku);
				imwrite("rikuUnNum.jpg", rikuUnNum); 
	
				rectangle(char_output, Point(leftSide4Digit, topLine), Point(boundRect[i].x + boundRect[i].width, topLine + boundRect[i].height + (boundRect[i].height* 0.05)), Scalar(0, 0,255), 2, 8, 0);
				rectangle(char_output, Point(leftSideKatakana, topLine), Point(leftSide4Digit, topLine + boundRect[i].height + (boundRect[i].height* 0.05)), Scalar(0, 0, 255), 2, 8, 0);
				rectangle(char_output, Point(leftSide4Digit,0), Point(boundRect[i].x, topLine), Scalar(0, 0, 255), 2, 8, 0);

				imshow("finalcharRectangleImage", char_output);

			}
		}
	}


}

