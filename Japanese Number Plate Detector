#include <iostream>
#include <opencv2\core\core.hpp>
#include <opencv2\highgui\highgui.hpp>
#include <opencv2\opencv.hpp>
#include <opencv2\imgproc\imgproc.hpp>
#include <vector>

using namespace cv;
using namespace std;

void connectIpCamera();
int readImage();
void convertBlur();
void morphologyOperate1();
void morphologyOperate2();
void blackHat();
void sobelOperate();
void binaryOtsuImage();
void countRowsCols();
void countBlackPixelsX();
void countBlackPixelsY();
void findingContours();
void mergeImage();

VideoCapture capture;
Mat first_image;
Mat grayscaleimage;
Mat binary1,binary2, equalize;
Mat temp_img, sobelImage;
Mat binaryOtsu;
Mat morpho,mergedCanny,binaryInverted;
Mat firstMerge;




int main(int argc, char *argv[]){

	connectIpCamera();

	for (;;){

	readImage();

	convertBlur();

//	countRowsCols();

//	blackHat();

	binaryOtsuImage();

//	morphologyOperate1();

//	morphologyOperate2();

//	sobelOperate();

//	mergeImage();

	findingContours();

	if (waitKey(1) >= 0) break;

	}

	waitKey(0);

	destroyAllWindows();

	return 0;
}


void connectIpCamera(){

	string uname = "root";
	string password = "*****";
	string ip_address = "http://" + uname + ":" + password + "@169.254.25.1/mjpg/video.mjpg"; // Axis Ip Camera

	if (capture.open(ip_address) == false) {
		cout << "Cannot connect IP camera! Check Your Camera Connection." << endl;
		waitKey();
	}
}

int readImage(){
	if (capture.read(first_image) == false){
		return -1;
	}
}

void countRowsCols(){
	cout << grayscaleimage.rows << endl;
	cout << grayscaleimage.cols << endl;
}

void morphologyOperate1(){
	Mat morphoImage = imread("morphology_img.jpg");
	threshold(morphoImage, binary1, 170, 255, CV_THRESH_BINARY);
	bitwise_not(binary1,binaryInverted);
	imshow("binaryInverted", binaryInverted);
	imshow("binary1", binary1);
}

void morphologyOperate2(){
	Mat morphoImage = imread("morphology_img.jpg");
	threshold(morphoImage, binary2, 200, 255, CV_THRESH_BINARY);
	bitwise_not(binary2, binaryInverted);
	imshow("binaryInverted", binaryInverted);
	imshow("binary2", binary2);

}
void blackHat(){
	
	int morph_size = 2;
	Mat element = getStructuringElement(MORPH_RECT, Size(2 * morph_size + 1, 2 * morph_size + 1), Point(morph_size, morph_size));
	morphologyEx(grayscaleimage, morpho, MORPH_CLOSE, element, Point(-1, -1));
	imshow("morpho", morpho);
	imwrite("morphology_img.jpg", morpho);
}

void convertBlur(){
	Mat blur;
	GaussianBlur(first_image, blur, Size(3, 3), 0, 0, BORDER_DEFAULT);
	cvtColor(blur, grayscaleimage, CV_BGR2GRAY);
	equalizeHist(grayscaleimage, equalize);
//	imshow("gray image", grayscaleimage);
	imshow("equalize", equalize);
}


void binaryOtsuImage(){
	threshold(equalize, binaryOtsu, 0, 255, CV_THRESH_BINARY | CV_THRESH_OTSU);
	imshow("otsu", binaryOtsu);
}


void mergeImage(){

	firstMerge = binary1.clone();
	Mat resultMerge = (equalize | binaryOtsu);
	Canny(resultMerge,mergedCanny,250,3,3);
	imshow("merged_image", resultMerge);
	imshow("mergedCanny", mergedCanny);
}

void sobelOperate(){

	Sobel(equalize, temp_img, CV_32F, 1, 0);
	convertScaleAbs(temp_img, sobelImage, 1, 1);
	imshow("sobel", sobelImage);
}
void findingContours(){
	Mat canny_output;

	vector<vector<Point> > contours;
	vector<Vec4i> hierarchy;

	Canny(binaryOtsu, canny_output, 250, 3, 3);
	imshow("canny_image", canny_output);

	/// Find contours
	findContours(canny_output, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));

	vector<vector<Point> > contours_poly(contours.size());
	vector<Rect> boundRect(contours.size());
	vector<Point2f>center(contours.size());
	vector<float>radius(contours.size());

	Mat rectangles = grayscaleimage.clone();
	Mat drawing = Mat::zeros(canny_output.size(), CV_8UC3);
	Scalar color = Scalar(255, 255, 0);



	for (size_t i = 0; i < contours.size(); i++){

		approxPolyDP(Mat(contours[i]), contours_poly[i], 3, true);
		boundRect[i] = boundingRect(Mat(contours_poly[i]));
		minEnclosingCircle(contours_poly[i], center[i], radius[i]);

		float aspectRatio = (float)boundRect[i].width / boundRect[i].height;

			if (boundRect[i].height > 30 && boundRect[i].width > 55 && aspectRatio > 1.8 && aspectRatio < 2.2){

//					drawContours(drawing, contours_poly, (int)i, color, 1, 8, vector<Vec4i>(), 0, Point());
					rectangle(drawing, boundRect[i].tl(), boundRect[i].br(), color, 1, 8, 0);
					rectangle(first_image, boundRect[i].tl(), boundRect[i].br(), color, 1, 8, 0);
//					circle(drawing, center[i], (int)radius[i], color, 2, 8, 0);

			}
        }
//	cout << contours.size() << endl;
//	imshow("Contours", drawing);
	imshow("contours_result", first_image);
}
void countBlackPixelsX(){
	int x, y;
	Mat histogramX = Mat(Size(binary1.cols, binary1.rows), CV_8UC3, Scalar(255, 255, 255));
	for (x = 0; x < binary1.cols; x++){
		int black = 0;
		for (y = 0; y < binary1.rows; y++){
			int intensity = binary1.at<uchar>(Point(x, y));
			if (intensity == 0){
				black += 1;
			}
		}
		line(histogramX, Point(x, 0), Point(x, black), Scalar(255, 0, 0), 1);
	}
	imshow("histogramX", histogramX);
}

void countBlackPixelsY(){
	int x, y;
	Mat histogramY = Mat(Size(binary1.cols, binary1.rows), CV_8UC3, Scalar(255, 255, 255));
	for (y = 0; y < binary1.rows; y++){
		int black = 0;
		for (x = 0; x < binary1.cols; x++){
			int intensity = binary1.at<uchar>(Point(x, y));
			if (intensity == 0){
				black += 1;
			}
		}
		line(histogramY, Point(0, y), Point(black, y), Scalar(255, 0, 0), 1);
	}
	imshow("histogramY", histogramY);
}
