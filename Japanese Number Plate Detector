#include <iostream>
#include <opencv2\core\core.hpp>
#include <opencv2\highgui\highgui.hpp>
#include <opencv2\opencv.hpp>
#include <opencv2\imgproc\imgproc.hpp>
#include <vector>

using namespace cv;
using namespace std;

void convertBlur();
void blackHat();
void sobelOperate();
void countRowsCols();
void countBlackPixelsX();
void countBlackPixelsY();
void findingContours();

Mat first_image = imread("test5.jpg");
Mat grayscaleimage;
Mat binary, equalize;
Mat temp_img, sobelImage;


int main(int argc, char *argv[])
{
	
	convertBlur();
	countRowsCols();

	blackHat();
	
	Mat morphoImage = imread("morphology_img.jpg");
	threshold(morphoImage, binary,173, 255, CV_THRESH_BINARY);
	imshow("binary", binary);

	sobelOperate();
	findingContours();

	waitKey(0);
	destroyAllWindows();
	return 0;
}

void countRowsCols(){
	cout << grayscaleimage.rows << endl;
	cout << grayscaleimage.cols << endl;
}

void countBlackPixelsX(){
	int x, y;
	Mat histogramX = Mat(Size(binary.cols,binary.rows),CV_8UC3,Scalar(255,255,255));
	for (x = 0; x < binary.cols; x++){
		int black = 0;
		for (y = 0; y < binary.rows; y++){
			int intensity = binary.at<uchar>(Point(x, y));
			if (intensity == 0){
				black += 1;
			}
		}
		line(histogramX, Point(x, 0), Point(x, black), Scalar(255, 0, 0), 1);
	}
	imshow("histogramX", histogramX);
}

void countBlackPixelsY(){
	int x, y;
	Mat histogramY = Mat(Size(binary.cols, binary.rows), CV_8UC3, Scalar(255, 255, 255));
	for (y = 0; y < binary.rows; y++){
		int black = 0;
		for (x = 0; x < binary.cols; x++){
			int intensity = binary.at<uchar>(Point(x, y));
			if (intensity == 0){
				black += 1;
			}
		}
		line(histogramY, Point(0, y), Point(black, y), Scalar(255, 0, 0), 1);
	}
	imshow("histogramY", histogramY);
}
void blackHat(){
	Mat morpho;
	int morph_size = 2;
	Mat element = getStructuringElement(MORPH_RECT, Size(2 * morph_size + 1, 2 * morph_size + 1), Point(morph_size, morph_size));
	morphologyEx(grayscaleimage, morpho, MORPH_CLOSE, element, Point(-1, -1));
	imshow("morpho", morpho);
	imwrite("morphology_img.jpg", morpho);
}

void convertBlur(){
	Mat blur;
	GaussianBlur(first_image, blur, Size(3, 3), 0, 0, BORDER_DEFAULT);
	cvtColor(blur, grayscaleimage, CV_BGR2GRAY);
	equalizeHist(grayscaleimage, equalize);
	imshow("gray image", grayscaleimage);
	imshow("equalize", equalize);
}

void sobelOperate(){

	Sobel(equalize, temp_img, CV_32F, 1, 0);
	convertScaleAbs(temp_img, sobelImage, 1, 1);
	imshow("sobel", sobelImage);
}
void findingContours(){
	Mat canny_output;

	vector<vector<Point> > contours;
	vector<Vec4i> hierarchy;

	Canny(binary, canny_output, 200, 3, 3);

	/// Find contours
	findContours(canny_output, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));

	vector<vector<Point> > contours_poly(contours.size());
	vector<Rect> boundRect(contours.size());
	vector<Point2f>center(contours.size());
	vector<float>radius(contours.size());

	for (size_t i = 0; i < contours.size(); i++){

			approxPolyDP(Mat(contours[i]), contours_poly[i], 3, true);
			boundRect[i] = boundingRect(Mat(contours_poly[i]));
			minEnclosingCircle(contours_poly[i], center[i], radius[i]);

			Mat rectangles = grayscaleimage.clone();
			Mat drawing = Mat::zeros(canny_output.size(), CV_8UC3);


			for (size_t i = 0; i < contours.size(); i++)
			{
				float aspectRatio = (float)boundRect[i].width /  boundRect[i].height;
				if (boundRect[i].height > 25 && boundRect[i].width && aspectRatio > 1.50 && aspectRatio < 2.10){
				Scalar color = Scalar(255, 255, 0);
				//		drawContours(drawing, contours_poly, (int)i, color, 1, 8, vector<Vec4i>(), 0, Point());
				rectangle(drawing, boundRect[i].tl(), boundRect[i].br(), color, 1, 8, 0);
				rectangle(rectangles, boundRect[i].tl(), boundRect[i].br(), color, 1, 8, 0);
				//		circle(drawing, center[i], (int)radius[i], color, 2, 8, 0);
			}

			/// Show in a window

			imshow("Contours", drawing);
			imshow("contours_fist", rectangles);
		}
	}
}
